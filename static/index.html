<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PALANTIR</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #050508; color: #e0e0e0;
      font-family: "Courier New", monospace;
      overflow: hidden; height: 100vh;
      display: flex; flex-direction: column;
    }

    /* HEADER */
    #header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 8px 20px; background: rgba(0,0,0,0.9);
      border-bottom: 1px solid #111; z-index: 10; flex-shrink: 0;
    }
    #header-left { display: flex; align-items: center; gap: 12px; }
    #header h1 { font-size: 11px; letter-spacing: 6px; color: #fff; text-transform: uppercase; }
    #header-sub { font-size: 9px; color: #333; letter-spacing: 3px; }
    #conn-dot { width: 7px; height: 7px; border-radius: 50%; background: #222; flex-shrink: 0; }
    #conn-dot.live  { background: #00ff88; box-shadow: 0 0 8px #00ff88; animation: pulsed 2s infinite; }
    #conn-dot.error { background: #ff3366; box-shadow: 0 0 8px #ff3366; }
    @keyframes pulsed { 0%,100%{opacity:1} 50%{opacity:.3} }
    #snap-label { font-size: 9px; color: #2a2a2a; letter-spacing: 2px; }

    /* SCENE */
    #scene { position: relative; flex: 1; overflow: hidden; }
    #video  { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); display: block; }
    #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); pointer-events: none; }

    /* SCAN LINE */
    #scan-line {
      position: absolute; top: 0; left: 0; right: 0; height: 2px;
      background: linear-gradient(90deg, transparent, #00ff8833, transparent);
      animation: scandown 5s linear infinite; z-index: 5; pointer-events: none;
    }
    @keyframes scandown { 0%{top:0%} 100%{top:100%} }

    /* CORNER BRACKETS */
    .corner {
      position: absolute; width: 22px; height: 22px;
      border-color: #00ff8830; border-style: solid; z-index: 6; pointer-events: none;
    }
    .corner-tl { top: 12px; left: 12px; border-width: 1px 0 0 1px; }
    .corner-tr { top: 12px; right: 12px; border-width: 1px 1px 0 0; }
    .corner-bl { bottom: 12px; left: 12px; border-width: 0 0 1px 1px; }
    .corner-br { bottom: 12px; right: 12px; border-width: 0 1px 1px 0; }

    /* STATUS BADGE */
    #status-badge {
      position: absolute; top: 14px; left: 50%; transform: translateX(-50%);
      z-index: 10; display: flex; align-items: center; gap: 7px;
      background: rgba(0,0,0,0.75); border: 1px solid #1a1a1a;
      border-radius: 20px; padding: 5px 14px;
      font-size: 9px; letter-spacing: 3px; text-transform: uppercase;
      transition: border-color 0.3s, color 0.3s;
      color: #444;
    }
    #status-badge.listening { border-color: #ff444477; color: #ff6666; }
    #status-badge.listening .bdot { background: #ff4444; box-shadow: 0 0 6px #ff4444; animation: pulsed .5s infinite; }
    #status-badge.speaking  { border-color: #4499ff77; color: #66aaff; }
    #status-badge.speaking  .bdot { background: #4499ff; box-shadow: 0 0 6px #4499ff; animation: pulsed .4s infinite; }
    #status-badge.standby   { border-color: #222; color: #333; }
    #status-badge.standby   .bdot { background: #333; }
    .bdot { width: 5px; height: 5px; border-radius: 50%; flex-shrink: 0; transition: background .3s; }

    /* SNAPSHOT BAR */
    #snap-bar {
      position: absolute; bottom: 0; left: 0; height: 2px;
      background: linear-gradient(90deg, #ff6600, #ffcc00);
      transition: width 0.5s linear; z-index: 11; width: 0%;
    }

    /* SNAPSHOT FLASH */
    #snap-flash {
      position: absolute; top: 14px; right: 110px; z-index: 12;
      font-size: 8px; letter-spacing: 2px; color: #ff660088;
      text-transform: uppercase; opacity: 0; transition: opacity .3s;
    }
    #snap-flash.show { opacity: 1; }

    /* PANEL */
    #panel {
      position: absolute; bottom: 0; left: 0; right: 0; z-index: 10;
      background: linear-gradient(to top, rgba(0,0,0,.97) 55%, transparent);
      padding: 50px 20px 16px;
    }

    /* WAVEFORM */
    #waveform { display: none; align-items: center; gap: 3px; margin-bottom: 10px; height: 22px; }
    #waveform.active { display: flex; }
    .wbar {
      width: 3px; background: #4499ff; border-radius: 2px;
      animation: wv .8s ease-in-out infinite;
    }
    .wbar:nth-child(1){animation-delay:0s}   .wbar:nth-child(2){animation-delay:.1s}
    .wbar:nth-child(3){animation-delay:.2s}  .wbar:nth-child(4){animation-delay:.3s}
    .wbar:nth-child(5){animation-delay:.4s}  .wbar:nth-child(6){animation-delay:.3s}
    .wbar:nth-child(7){animation-delay:.2s}  .wbar:nth-child(8){animation-delay:.1s}
    @keyframes wv { 0%,100%{height:4px} 50%{height:20px} }

    /* AI TEXT BOX */
    #ai-box {
      background: rgba(0,20,60,.4); border: 1px solid rgba(68,153,255,.15);
      border-radius: 6px; padding: 12px 16px; margin-bottom: 10px;
      min-height: 50px; display: flex; align-items: flex-start; gap: 10px;
    }
    #ai-icon { font-size: 16px; flex-shrink: 0; margin-top: 2px; }
    #ai-text { font-size: 14px; color: #88bbee; line-height: 1.55; font-style: italic; flex: 1; }
    #ai-text.typing::after { content: "\258B"; animation: blink .55s infinite; color: #4499ff; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0} }

    /* META */
    #meta { display: flex; gap: 14px; font-size: 10px; color: #333; flex-wrap: wrap; align-items: center; }
    #meta span { display: flex; align-items: center; gap: 4px; }
    #meta strong { color: #555; }
    .msep { color: #1a1a1a; }

    /* BUTTONS */
    .ctrl-btn {
      position: absolute; top: 12px; z-index: 12;
      background: rgba(0,0,0,.6); border: 1px solid #222; color: #555;
      font-size: 14px; width: 32px; height: 32px; cursor: pointer;
      border-radius: 6px; transition: all .2s;
      display: none; align-items: center; justify-content: center;
    }
    .ctrl-btn.show { display: flex; }
    .ctrl-btn:hover { border-color: #555; color: #bbb; }
    #mic-btn { right: 56px; }
    #mic-btn.muted { border-color: #ff444444; color: #ff6644; }
    #spk-btn { right: 14px; }

    /* SPLASH */
    #splash {
      position: absolute; inset: 0; background: #050508;
      display: flex; flex-direction: column; align-items: center;
      justify-content: center; gap: 18px; z-index: 100;
    }
    .sp-eyebrow { font-size: 9px; letter-spacing: 6px; color: #222; text-transform: uppercase; }
    .sp-title   { font-size: 44px; letter-spacing: 10px; color: #fff; font-weight: bold; }
    .sp-sub     { font-size: 9px; letter-spacing: 4px; color: #2a2a2a; text-transform: uppercase; }
    .sp-divider { width: 36px; height: 1px; background: #1a1a1a; }
    .sp-body    { font-size: 11px; color: #333; text-align: center; max-width: 340px; line-height: 2.1; margin-top: 6px; }
    #start-btn {
      padding: 13px 48px; background: transparent;
      border: 1px solid #1a1a1a; color: #444;
      font-family: inherit; font-size: 10px; letter-spacing: 5px;
      cursor: pointer; border-radius: 4px; text-transform: uppercase;
      transition: all .2s; margin-top: 10px;
    }
    #start-btn:hover { border-color: #ff3333; color: #ff5555; box-shadow: 0 0 30px rgba(255,30,30,.08); }
    #start-btn:disabled { opacity: .25; cursor: not-allowed; color: #333; border-color: #111; box-shadow: none; }
    #load-status { font-size: 10px; color: #2a2a2a; letter-spacing: 2px; min-height: 14px; }
  </style>
</head>
<body>

<div id="header">
  <div id="header-left">
    <div id="conn-dot"></div>
    <div>
      <h1>&#x2622; PALANTIR</h1>
      <div id="header-sub">UNIT 8200 &nbsp;&middot;&nbsp; MOSSAD &nbsp;&middot;&nbsp; IDF &nbsp;&middot;&nbsp; SURVEILLANCE ACTIVE</div>
    </div>
  </div>
  <div id="snap-label">SNAPSHOT: --</div>
</div>

<div id="scene">
  <video id="video" playsinline autoplay muted></video>
  <canvas id="canvas"></canvas>

  <div class="corner corner-tl"></div>
  <div class="corner corner-tr"></div>
  <div class="corner corner-bl"></div>
  <div class="corner corner-br"></div>
  <div id="scan-line"></div>

  <div id="status-badge" class="standby">
    <div class="bdot"></div>
    <span id="badge-text">STANDBY</span>
  </div>
  <span id="snap-flash">&#x25A0; SNAPSHOT SENT</span>

  <button id="mic-btn" class="ctrl-btn" title="Toggle mic">&#x1F399;</button>
  <button id="spk-btn" class="ctrl-btn" title="Toggle speaker">&#x1F50A;</button>

  <div id="panel">
    <div id="waveform">
      <div class="wbar"></div><div class="wbar"></div>
      <div class="wbar"></div><div class="wbar"></div>
      <div class="wbar"></div><div class="wbar"></div>
      <div class="wbar"></div><div class="wbar"></div>
    </div>
    <div id="ai-box">
      <span id="ai-icon">&#x1F9FF;</span>
      <div id="ai-text">Establishing secure channel with Mossad relay&hellip;</div>
    </div>
    <div id="meta">
      <span>&#x1F464; <strong id="face-count">0</strong> faces</span>
      <span class="msep">|</span>
      <span>&#x270B; <strong id="hand-count">0</strong> hands</span>
      <span class="msep">|</span>
      <span>&#x1F4E1; <strong id="vibe-text">scanning</strong></span>
    </div>
  </div>

  <div id="snap-bar"></div>
</div>

<div id="splash">
  <div class="sp-eyebrow">Classified &mdash; Level 5 Clearance</div>
  <div class="sp-title">PALANTIR</div>
  <div class="sp-sub">Mossad &nbsp;&middot;&nbsp; Unit 8200 &nbsp;&middot;&nbsp; IDF &nbsp;&middot;&nbsp; Palantir Technologies</div>
  <div class="sp-divider"></div>
  <p class="sp-body">
    Real-time facial surveillance &amp; voice interrogation.<br>
    Your biometrics are being ingested into Palantir AIP.<br>
    Speak freely &mdash; it won&apos;t help.
  </p>
  <button id="start-btn">Authorize Access</button>
  <div id="load-status"></div>
</div>

<script type="module">
import {
  FaceLandmarker, HandLandmarker,
  FilesetResolver, DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs";

// DOM refs
const video       = document.getElementById("video");
const canvas      = document.getElementById("canvas");
const ctx         = canvas.getContext("2d");
const connDot     = document.getElementById("conn-dot");
const statusBadge = document.getElementById("status-badge");
const badgeText   = document.getElementById("badge-text");
const aiText      = document.getElementById("ai-text");
const faceCount   = document.getElementById("face-count");
const handCount   = document.getElementById("hand-count");
const vibeText    = document.getElementById("vibe-text");
const snapBar     = document.getElementById("snap-bar");
const snapLabel   = document.getElementById("snap-label");
const snapFlash   = document.getElementById("snap-flash");
const waveform    = document.getElementById("waveform");
const splash      = document.getElementById("splash");
const startBtn    = document.getElementById("start-btn");
const loadStatus  = document.getElementById("load-status");
const micBtn      = document.getElementById("mic-btn");
const spkBtn      = document.getElementById("spk-btn");

let faceLandmarker, handLandmarker, drawingUtils;
let latestFaceResult = { faceLandmarks: [] };
let latestHandResult = { landmarks: [], handedness: [] };
let micMuted = false;
let spkMuted = false;
let liveWs   = null;

// ---- Playback audio (24kHz PCM from Gemini) ------------------------------
const OUT_SR     = 24000;
let outCtx       = null;
let nextPlayTime = 0;
let isSpeaking   = false;
let speakTimer   = null;

function initOutAudio() {
  outCtx = new AudioContext({ sampleRate: OUT_SR });
  nextPlayTime = outCtx.currentTime;
}

function schedulePCM(bytes) {
  if (!outCtx || spkMuted) return;
  const i16 = new Int16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength >> 1);
  const f32 = new Float32Array(i16.length);
  for (let i = 0; i < i16.length; i++) f32[i] = i16[i] / 32768;
  const buf = outCtx.createBuffer(1, f32.length, OUT_SR);
  buf.getChannelData(0).set(f32);
  const src = outCtx.createBufferSource();
  src.buffer = buf;
  src.connect(outCtx.destination);
  const when = Math.max(nextPlayTime, outCtx.currentTime + 0.02);
  src.start(when);
  nextPlayTime = when + buf.duration;
  setSpeaking(true);
  clearTimeout(speakTimer);
  speakTimer = setTimeout(() => setSpeaking(false), 700);
}

function setSpeaking(on) {
  if (isSpeaking === on) return;
  isSpeaking = on;
  if (on) {
    setStatus("speaking");
    waveform.classList.add("active");
  } else {
    waveform.classList.remove("active");
    setStatus(micMuted ? "standby" : "listening");
  }
}

// ---- Microphone capture -> 16kHz PCM16 -----------------------------------
const WORKLET_CODE = `
class MicProcessor extends AudioWorkletProcessor {
  constructor() { super(); this._buf = []; this._chunk = 1600; }
  process(inputs) {
    const ch = inputs[0] && inputs[0][0];
    if (!ch) return true;
    for (let i = 0; i < ch.length; i++) {
      this._buf.push(ch[i]);
      if (this._buf.length >= this._chunk) {
        const i16 = new Int16Array(this._chunk);
        for (let j = 0; j < this._chunk; j++)
          i16[j] = Math.max(-32768, Math.min(32767, Math.round(this._buf[j] * 32767)));
        this.port.postMessage(i16.buffer, [i16.buffer]);
        this._buf = [];
      }
    }
    return true;
  }
}
registerProcessor('mic-processor', MicProcessor);
`;

let micCtx = null;

async function startMic() {
  let micStream;
  try {
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true }
    });
  } catch (e) {
    console.error("[mic]", e); return;
  }
  micCtx = new AudioContext({ sampleRate: 16000 });
  const blob = new Blob([WORKLET_CODE], { type: "application/javascript" });
  const url  = URL.createObjectURL(blob);
  await micCtx.audioWorklet.addModule(url);
  URL.revokeObjectURL(url);
  const src  = micCtx.createMediaStreamSource(micStream);
  const node = new AudioWorkletNode(micCtx, "mic-processor");
  node.port.onmessage = (e) => {
    if (!micMuted && liveWs && liveWs.readyState === WebSocket.OPEN)
      liveWs.send(e.data);
  };
  src.connect(node);
  micBtn.classList.remove("muted");
}

// ---- Live WebSocket -------------------------------------------------------
function connectLive() {
  const proto = location.protocol === "https:" ? "wss" : "ws";
  liveWs = new WebSocket(`${proto}://${location.host}/ws/live`);
  liveWs.binaryType = "arraybuffer";

  liveWs.onopen = () => {
    connDot.className = "live";
    setStatus(micMuted ? "standby" : "listening");
    typewrite(aiText,
      "PALANTIR online. Mossad relay established. " +
      "Palantir AIP is now ingesting your biometrics. " +
      "You may speak -- Unit 8200 is already judging you."
    );
  };

  liveWs.onmessage = (e) => {
    if (typeof e.data === "string") {
      if (e.data.startsWith("TEXT:")) {
        const txt = e.data.slice(5).trim();
        if (txt) typewrite(aiText, txt);
      } else if (e.data.startsWith("ERROR:")) {
        typewrite(aiText, "[SYSTEM ERROR] " + e.data.slice(6));
        connDot.className = "error";
      }
      // "END" = turn complete, just ignore
    } else {
      schedulePCM(new Uint8Array(e.data));
    }
  };

  liveWs.onclose = () => {
    connDot.className = "error";
    setStatus("standby");
    setTimeout(connectLive, 3000);
  };

  liveWs.onerror = (err) => console.error("[live ws]", err);
}

function sendScene(scene) {
  if (liveWs && liveWs.readyState === WebSocket.OPEN) {
    liveWs.send("SCENE:" + scene);
    snapFlash.classList.add("show");
    setTimeout(() => snapFlash.classList.remove("show"), 1800);
  }
}

// ---- Status helper -------------------------------------------------------
function setStatus(state) {
  statusBadge.className = state;
  badgeText.textContent =
    state === "listening" ? "LISTENING" :
    state === "speaking"  ? "SPEAKING"  : "STANDBY";
}

// ---- Typewriter ----------------------------------------------------------
function typewrite(el, text, speed = 22) {
  el.classList.add("typing");
  el.textContent = "";
  let i = 0;
  const iv = setInterval(() => {
    if (i < text.length) el.textContent += text[i++];
    else { clearInterval(iv); el.classList.remove("typing"); }
  }, speed);
}

// ---- Snapshot timer (every 45s) ------------------------------------------
const SNAP_INTERVAL = 45000;
let lastSnapTime    = 0;

function updateSnap(ts) {
  const elapsed = ts - lastSnapTime;
  const pct     = Math.min(elapsed / SNAP_INTERVAL, 1);
  snapBar.style.width = (pct * 100) + "%";
  const sec = Math.max(0, Math.ceil((SNAP_INTERVAL - elapsed) / 1000));
  snapLabel.textContent = "SNAPSHOT: " + sec + "s";
  if (elapsed >= SNAP_INTERVAL) {
    lastSnapTime = ts;
    sendScene(buildScene(latestFaceResult, latestHandResult));
  }
}

// ---- Landmark helpers ----------------------------------------------------
function dist(a, b) { return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); }

function describeFace(lms, id) {
  const faceH = dist(lms[10], lms[152]);
  if (faceH < 0.001) return null;
  const mO = dist(lms[13], lms[14]) / faceH;
  const mW = dist(lms[61], lms[291]) / faceH;
  const lE = dist(lms[159], lms[145]) / faceH;
  const rE = dist(lms[386], lms[374]) / faceH;
  const lB = (lms[33].y  - lms[70].y)  / faceH;
  const rB = (lms[263].y - lms[300].y) / faceH;
  const tl = (lms[234].y - lms[454].y) / faceH;
  const mouth = mO > 0.06 ? (mO > 0.12 ? "wide open" : "slightly open") : "closed";
  const smile = mW > 0.42 && mO < 0.08 ? ", smiling" : "";
  const eyes  = ((lE+rE)/2) < 0.025 ? "squinting" : ((lE+rE)/2) > 0.05 ? "wide open" : "normal";
  const brows = ((lB+rB)/2) > 0.08 ? "raised/anxious" : ((lB+rB)/2) < 0.02 ? "furrowed/focused" : "neutral";
  const head  = Math.abs(tl) < 0.03 ? "level" : tl > 0 ? "tilted right" : "tilted left";
  return `Subject ${id}: mouth ${mouth}${smile}, eyes ${eyes}, brows ${brows}, head ${head}`;
}

function describeHand(lms, hand, id) {
  const tips = [4,8,12,16,20], pips = [3,6,10,14,18];
  const names = ["thumb","index","middle","ring","pinky"];
  const ext = names.filter((_,i) => lms[tips[i]].y < lms[pips[i]].y);
  const g   = ext.length === 0 ? "fist" : ext.length === 5 ? "open hand" : ext.join("+") + " extended";
  return `Hand ${id} (${hand}): ${g}`;
}

function buildScene(fr, hr) {
  const p = [];
  fr.faceLandmarks.forEach((l,i) => { const d = describeFace(l,i+1); if (d) p.push(d); });
  hr.landmarks.forEach((l,i) => {
    const h = hr.handedness[i]?.[0]?.displayName ?? "Unknown";
    p.push(describeHand(l, h, i+1));
  });
  return p.length ? p.join(" | ") : "No subjects detected in frame.";
}

// ---- Boot ----------------------------------------------------------------
async function boot() {
  startBtn.disabled = true;

  const fail = (msg) => {
    loadStatus.style.color = "#ff4444";
    loadStatus.textContent = msg;
    startBtn.disabled = false;
  };

  loadStatus.style.color = "";
  loadStatus.textContent = "Requesting camera access...";

  if (!navigator.mediaDevices?.getUserMedia) {
    fail("Camera API unavailable -- use Chrome at http://localhost:8000");
    return;
  }

  let stream;
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
  } catch (e) { fail("Camera error: " + e.message); return; }

  loadStatus.textContent = "Starting video feed...";
  video.srcObject = stream;
  try { await video.play(); }
  catch (e) {
    fail("Video play() failed: " + e.message);
    stream.getTracks().forEach(t => t.stop()); video.srcObject = null; return;
  }

  loadStatus.textContent = "Loading AI vision models...";
  try {
    const wasmUrl = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm";
    const vision  = await FilesetResolver.forVisionTasks(wasmUrl);
    [faceLandmarker, handLandmarker] = await Promise.all([
      FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO", numFaces: 4,
        minFaceDetectionConfidence: 0.5,
        minFacePresenceConfidence:  0.5,
        minTrackingConfidence:      0.5,
      }),
      HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO", numHands: 4,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence:  0.5,
        minTrackingConfidence:      0.5,
      }),
    ]);
  } catch (e) {
    fail("Model load failed: " + e.message);
    stream.getTracks().forEach(t => t.stop()); video.srcObject = null; return;
  }
  drawingUtils = new DrawingUtils(ctx);

  if (!video.videoWidth || !video.videoHeight) {
    fail("No video signal -- try reloading");
    stream.getTracks().forEach(t => t.stop()); video.srcObject = null; return;
  }

  // Hide splash, show controls
  splash.style.display = "none";
  micBtn.classList.add("show");
  spkBtn.classList.add("show");
  lastSnapTime = performance.now() - (SNAP_INTERVAL - 8000); // first snapshot in ~8s

  // Init audio + WebSocket (requires user gesture)
  initOutAudio();
  connectLive();
  await startMic();

  requestAnimationFrame(renderLoop);
}

// ---- Render loop ---------------------------------------------------------
function renderLoop() {
  if (video.readyState < 2) { requestAnimationFrame(renderLoop); return; }

  if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const ts = performance.now();
  latestFaceResult = faceLandmarker.detectForVideo(video, ts);
  latestHandResult = handLandmarker.detectForVideo(video, ts);

  // Face mesh
  for (const lms of latestFaceResult.faceLandmarks) {
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_TESSELATION,
      { color: "#FFFFFF07", lineWidth: 0.3 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL,
      { color: "#ffffff18", lineWidth: 1 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE,
      { color: "#00C8FF", lineWidth: 1.2 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE,
      { color: "#00C8FF", lineWidth: 1.2 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_LIPS,
      { color: "#FF4466", lineWidth: 1.5 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_LEFT_EYEBROW,
      { color: "#ffcc0066", lineWidth: 1 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYEBROW,
      { color: "#ffcc0066", lineWidth: 1 });
  }

  // Hands
  for (const lms of latestHandResult.landmarks) {
    drawingUtils.drawConnectors(lms, HandLandmarker.HAND_CONNECTIONS,
      { color: "#00FF5555", lineWidth: 2 });
    drawingUtils.drawLandmarks(lms,
      { radius: 3, color: "#00CCFF", fillColor: "#00CCFF33" });
  }

  // Counters & vibe
  faceCount.textContent = latestFaceResult.faceLandmarks.length;
  handCount.textContent = latestHandResult.landmarks.length;
  vibeText.textContent  = latestFaceResult.faceLandmarks.length > 0 ? "target acquired" : "no target";

  updateSnap(ts);
  requestAnimationFrame(renderLoop);
}

// ---- Buttons -------------------------------------------------------------
micBtn.onclick = () => {
  micMuted = !micMuted;
  micBtn.innerHTML = micMuted ? "&#x1F507;" : "&#x1F399;";
  micBtn.classList.toggle("muted", micMuted);
  if (!isSpeaking) setStatus(micMuted ? "standby" : "listening");
};

spkBtn.onclick = () => {
  spkMuted = !spkMuted;
  spkBtn.innerHTML = spkMuted ? "&#x1F507;" : "&#x1F50A;";
};

startBtn.addEventListener("click", boot);
</script>
</body>
</html>
