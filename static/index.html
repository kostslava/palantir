<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PALANTIR</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #050508; color: #e0e0e0;
      font-family: "Courier New", monospace;
      overflow: hidden; height: 100vh;
      display: flex; flex-direction: column;
    }

    /* HEADER */
    #header {
      display: flex; align-items: center; gap: 12px;
      padding: 8px 20px; background: rgba(0,0,0,0.9);
      border-bottom: 1px solid #111; z-index: 10; flex-shrink: 0;
    }
    #conn-dot { width: 7px; height: 7px; border-radius: 50%; background: #222; flex-shrink: 0; }
    #conn-dot.live  { background: #00ff88; box-shadow: 0 0 8px #00ff88; animation: pulsed 2s infinite; }
    #conn-dot.error { background: #ff3366; box-shadow: 0 0 8px #ff3366; }
    @keyframes pulsed { 0%,100%{opacity:1} 50%{opacity:.3} }
    #header h1 { font-size: 11px; letter-spacing: 6px; color: #fff; text-transform: uppercase; }
    #header-sub { font-size: 9px; color: #333; letter-spacing: 3px; }

    /* SCENE */
    #scene { position: relative; flex: 1; overflow: hidden; }
    #video  { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); display: block; }
    #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); pointer-events: none; }

    /* SCAN LINE */
    #scan-line {
      position: absolute; top: 0; left: 0; right: 0; height: 2px;
      background: linear-gradient(90deg, transparent, #00ff8833, transparent);
      animation: scandown 5s linear infinite; z-index: 5; pointer-events: none;
    }
    @keyframes scandown { 0%{top:0%} 100%{top:100%} }

    /* CORNER BRACKETS */
    .corner {
      position: absolute; width: 22px; height: 22px;
      border-color: #00ff8830; border-style: solid; z-index: 6; pointer-events: none;
    }
    .corner-tl { top: 12px; left: 12px; border-width: 1px 0 0 1px; }
    .corner-tr { top: 12px; right: 12px; border-width: 1px 1px 0 0; }
    .corner-bl { bottom: 12px; left: 12px; border-width: 0 0 1px 1px; }
    .corner-br { bottom: 12px; right: 12px; border-width: 0 1px 1px 0; }

    /* STATUS BADGE */
    #status-badge {
      position: absolute; top: 14px; left: 50%; transform: translateX(-50%);
      z-index: 10; display: flex; align-items: center; gap: 7px;
      background: rgba(0,0,0,0.75); border: 1px solid #1a1a1a;
      border-radius: 20px; padding: 5px 14px;
      font-size: 9px; letter-spacing: 3px; text-transform: uppercase;
      transition: border-color 0.3s, color 0.3s; color: #444;
    }
    #status-badge.listening { border-color: #ff444477; color: #ff6666; }
    #status-badge.listening .bdot { background: #ff4444; box-shadow: 0 0 6px #ff4444; animation: pulsed .5s infinite; }
    #status-badge.speaking  { border-color: #4499ff77; color: #66aaff; }
    #status-badge.speaking  .bdot { background: #4499ff; box-shadow: 0 0 6px #4499ff; animation: pulsed .4s infinite; }
    #status-badge.standby   { border-color: #222; color: #333; }
    #status-badge.standby   .bdot { background: #333; }
    .bdot { width: 5px; height: 5px; border-radius: 50%; flex-shrink: 0; }

    /* WAVEFORM (shown when AI is speaking) */
    #waveform {
      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);
      z-index: 10; display: none; align-items: center; gap: 3px; height: 28px;
    }
    #waveform.active { display: flex; }
    .wbar { width: 3px; background: #4499ff88; border-radius: 2px; animation: wv .8s ease-in-out infinite; }
    .wbar:nth-child(1){animation-delay:0s}  .wbar:nth-child(2){animation-delay:.1s}
    .wbar:nth-child(3){animation-delay:.2s} .wbar:nth-child(4){animation-delay:.3s}
    .wbar:nth-child(5){animation-delay:.4s} .wbar:nth-child(6){animation-delay:.3s}
    .wbar:nth-child(7){animation-delay:.2s} .wbar:nth-child(8){animation-delay:.1s}
    @keyframes wv { 0%,100%{height:4px} 50%{height:24px} }

    /* META (bottom left) */
    #meta {
      position: absolute; bottom: 14px; left: 18px; z-index: 10;
      display: flex; gap: 12px; font-size: 10px; color: #2a2a2a;
    }
    #meta strong { color: #444; }

    /* BUTTONS */
    .ctrl-btn {
      position: absolute; top: 12px; z-index: 12;
      background: rgba(0,0,0,.6); border: 1px solid #222; color: #555;
      font-size: 14px; width: 32px; height: 32px; cursor: pointer;
      border-radius: 6px; transition: all .2s;
      display: none; align-items: center; justify-content: center;
    }
    .ctrl-btn.show { display: flex; }
    .ctrl-btn:hover { border-color: #555; color: #bbb; }
    #mic-btn { right: 56px; }
    #mic-btn.muted { border-color: #ff444444; color: #ff6644; }
    #spk-btn { right: 14px; }

    /* SPLASH */
    #splash {
      position: absolute; inset: 0; background: #050508;
      display: flex; flex-direction: column; align-items: center;
      justify-content: center; gap: 18px; z-index: 100;
    }
    .sp-eyebrow { font-size: 9px; letter-spacing: 6px; color: #222; text-transform: uppercase; }
    .sp-title   { font-size: 44px; letter-spacing: 10px; color: #fff; font-weight: bold; }
    .sp-sub     { font-size: 9px; letter-spacing: 4px; color: #2a2a2a; text-transform: uppercase; }
    .sp-divider { width: 36px; height: 1px; background: #1a1a1a; }
    .sp-body    { font-size: 11px; color: #333; text-align: center; max-width: 340px; line-height: 2.1; margin-top: 6px; }
    #start-btn {
      padding: 13px 48px; background: transparent;
      border: 1px solid #1a1a1a; color: #444;
      font-family: inherit; font-size: 10px; letter-spacing: 5px;
      cursor: pointer; border-radius: 4px; text-transform: uppercase;
      transition: all .2s; margin-top: 10px;
    }
    #start-btn:hover { border-color: #ff3333; color: #ff5555; box-shadow: 0 0 30px rgba(255,30,30,.08); }
    #start-btn:disabled { opacity: .25; cursor: not-allowed; color: #333; border-color: #111; box-shadow: none; }
    #load-status { font-size: 10px; color: #2a2a2a; letter-spacing: 2px; min-height: 14px; }
  </style>
</head>
<body>

<div id="header">
  <div id="conn-dot"></div>
  <div>
    <h1>&#x2622; PALANTIR</h1>
    <div id="header-sub">UNIT 8200 &nbsp;&middot;&nbsp; MOSSAD &nbsp;&middot;&nbsp; IDF &nbsp;&middot;&nbsp; SURVEILLANCE ACTIVE</div>
  </div>
</div>

<div id="scene">
  <video id="video" playsinline autoplay muted></video>
  <canvas id="canvas"></canvas>

  <div class="corner corner-tl"></div>
  <div class="corner corner-tr"></div>
  <div class="corner corner-bl"></div>
  <div class="corner corner-br"></div>
  <div id="scan-line"></div>

  <div id="status-badge" class="standby">
    <div class="bdot"></div>
    <span id="badge-text">STANDBY</span>
  </div>

  <div id="waveform">
    <div class="wbar"></div><div class="wbar"></div>
    <div class="wbar"></div><div class="wbar"></div>
    <div class="wbar"></div><div class="wbar"></div>
    <div class="wbar"></div><div class="wbar"></div>
  </div>

  <button id="mic-btn" class="ctrl-btn" title="Toggle mic">&#x1F399;</button>
  <button id="spk-btn" class="ctrl-btn" title="Toggle speaker">&#x1F50A;</button>

  <div id="meta">
    <span>&#x1F464; <strong id="face-count">0</strong></span>
    <span>&#x270B; <strong id="hand-count">0</strong></span>
  </div>
</div>

<div id="splash">
  <div class="sp-eyebrow">Classified &mdash; Level 5 Clearance</div>
  <div class="sp-title">PALANTIR</div>
  <div class="sp-sub">Mossad &nbsp;&middot;&nbsp; Unit 8200 &nbsp;&middot;&nbsp; IDF &nbsp;&middot;&nbsp; Palantir Technologies</div>
  <div class="sp-divider"></div>
  <p class="sp-body">
    Real-time facial surveillance &amp; voice interrogation.<br>
    Your biometrics are being ingested into Palantir AIP.<br>
    Speak freely &mdash; it won&apos;t help.
  </p>
  <button id="start-btn">Authorize Access</button>
  <div id="load-status"></div>
</div>

<script type="module">
import {
  FaceLandmarker, HandLandmarker,
  FilesetResolver, DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs";

const video       = document.getElementById("video");
const canvas      = document.getElementById("canvas");
const ctx         = canvas.getContext("2d");
const connDot     = document.getElementById("conn-dot");
const statusBadge = document.getElementById("status-badge");
const badgeText   = document.getElementById("badge-text");
const waveform    = document.getElementById("waveform");
const faceCount   = document.getElementById("face-count");
const handCount   = document.getElementById("hand-count");
const splash      = document.getElementById("splash");
const startBtn    = document.getElementById("start-btn");
const loadStatus  = document.getElementById("load-status");
const micBtn      = document.getElementById("mic-btn");
const spkBtn      = document.getElementById("spk-btn");

let faceLandmarker, handLandmarker, drawingUtils;
let latestFaceResult = { faceLandmarks: [] };
let latestHandResult = { landmarks: [], handedness: [] };
let micMuted = false;
let spkMuted = false;
let liveWs   = null;

// ── Playback: 24kHz PCM from Gemini ───────────────────────────────────────
const OUT_SR = 24000;
let outCtx       = null;
let nextPlayTime = 0;
let isSpeaking   = false;
let speakTimer   = null;

function initOutAudio() {
  outCtx = new AudioContext({ sampleRate: OUT_SR });
  nextPlayTime = outCtx.currentTime;
}

function schedulePCM(bytes) {
  if (spkMuted || !outCtx) return;
  if (outCtx.state === "suspended") outCtx.resume();
  if (bytes.byteLength < 2) return;
  const i16 = new Int16Array(bytes.buffer, bytes.byteOffset, Math.floor(bytes.byteLength / 2));
  if (!i16.length) return;
  const f32 = new Float32Array(i16.length);
  for (let i = 0; i < i16.length; i++) f32[i] = i16[i] / 32768;
  const buf = outCtx.createBuffer(1, f32.length, OUT_SR);
  buf.getChannelData(0).set(f32);
  const src = outCtx.createBufferSource();
  src.buffer = buf;
  src.connect(outCtx.destination);
  if (nextPlayTime < outCtx.currentTime) nextPlayTime = outCtx.currentTime;
  src.start(nextPlayTime + 0.01);
  nextPlayTime += 0.01 + buf.duration;
  setSpeaking(true);
  clearTimeout(speakTimer);
  speakTimer = setTimeout(() => setSpeaking(false), 800);
}

function setSpeaking(on) {
  if (isSpeaking === on) return;
  isSpeaking = on;
  if (on) {
    setStatus("speaking");
    waveform.classList.add("active");
  } else {
    waveform.classList.remove("active");
    setStatus(micMuted ? "standby" : "listening");
  }
}

// ── Microphone: 16kHz PCM16 via AudioWorklet ──────────────────────────────
const WORKLET_CODE = `
class MicProcessor extends AudioWorkletProcessor {
  constructor() { super(); this._buf = []; this._chunk = 1600; }
  process(inputs) {
    const ch = inputs[0]?.[0];
    if (!ch) return true;
    for (let i = 0; i < ch.length; i++) {
      this._buf.push(ch[i]);
      if (this._buf.length >= this._chunk) {
        const i16 = new Int16Array(this._chunk);
        for (let j = 0; j < this._chunk; j++)
          i16[j] = Math.max(-32768, Math.min(32767, Math.round(this._buf[j] * 32767)));
        this.port.postMessage(i16.buffer, [i16.buffer]);
        this._buf = [];
      }
    }
    return true;
  }
}
registerProcessor('mic-processor', MicProcessor);
`;

async function startMic() {
  let stream;
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      audio: { channelCount: 1, sampleRate: 16000, echoCancellation: true, noiseSuppression: true }
    });
  } catch (e) { console.error("[mic]", e); return; }

  const micCtx = new AudioContext({ sampleRate: 16000 });
  const url = URL.createObjectURL(new Blob([WORKLET_CODE], { type: "application/javascript" }));
  await micCtx.audioWorklet.addModule(url);
  URL.revokeObjectURL(url);

  const src  = micCtx.createMediaStreamSource(stream);
  const node = new AudioWorkletNode(micCtx, "mic-processor");
  node.port.onmessage = (e) => {
    if (!micMuted && liveWs?.readyState === WebSocket.OPEN)
      liveWs.send(e.data);
  };
  src.connect(node);
}

// ── WebSocket ──────────────────────────────────────────────────────────────
function connectLive() {
  const proto = location.protocol === "https:" ? "wss" : "ws";
  liveWs = new WebSocket(`${proto}://${location.host}/ws/live`);
  liveWs.binaryType = "arraybuffer";

  liveWs.onopen = () => {
    connDot.className = "live";
    setStatus("listening");
  };

  liveWs.onmessage = (e) => {
    if (e.data instanceof ArrayBuffer) {
      schedulePCM(new Uint8Array(e.data));
    }
    // ignore any stray text frames
  };

  liveWs.onclose = () => {
    connDot.className = "error";
    setStatus("standby");
    setTimeout(connectLive, 3000);
  };

  liveWs.onerror = (err) => console.error("[ws]", err);
}

// ── Status ─────────────────────────────────────────────────────────────────
function setStatus(state) {
  statusBadge.className = state;
  badgeText.textContent =
    state === "listening" ? "LISTENING" :
    state === "speaking"  ? "SPEAKING"  : "STANDBY";
}

// ── Boot ───────────────────────────────────────────────────────────────────
async function boot() {
  startBtn.disabled = true;

  const fail = (msg) => {
    loadStatus.style.color = "#ff4444";
    loadStatus.textContent = msg;
    startBtn.disabled = false;
  };

  loadStatus.style.color = "";
  loadStatus.textContent = "Requesting camera access...";

  if (!navigator.mediaDevices?.getUserMedia) {
    fail("Camera API unavailable -- use Chrome at http://localhost:8000");
    return;
  }

  let stream;
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
  } catch (e) { fail("Camera error: " + e.message); return; }

  video.srcObject = stream;
  try { await video.play(); } catch (e) { fail("Video error: " + e.message); return; }

  loadStatus.textContent = "Loading AI vision models...";
  try {
    const wasmUrl = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm";
    const vision  = await FilesetResolver.forVisionTasks(wasmUrl);
    [faceLandmarker, handLandmarker] = await Promise.all([
      FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO", numFaces: 4,
        minFaceDetectionConfidence: 0.5, minFacePresenceConfidence: 0.5, minTrackingConfidence: 0.5,
      }),
      HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO", numHands: 4,
        minHandDetectionConfidence: 0.5, minHandPresenceConfidence: 0.5, minTrackingConfidence: 0.5,
      }),
    ]);
  } catch (e) { fail("Model load failed: " + e.message); return; }
  drawingUtils = new DrawingUtils(ctx);

  splash.style.display = "none";
  micBtn.classList.add("show");
  spkBtn.classList.add("show");

  initOutAudio();
  await outCtx.resume();
  connectLive();
  await startMic();

  requestAnimationFrame(renderLoop);
}

// ── Render loop ────────────────────────────────────────────────────────────
function renderLoop() {
  if (video.readyState < 2) { requestAnimationFrame(renderLoop); return; }
  if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const ts = performance.now();
  latestFaceResult = faceLandmarker.detectForVideo(video, ts);
  latestHandResult = handLandmarker.detectForVideo(video, ts);

  for (const lms of latestFaceResult.faceLandmarks) {
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_TESSELATION,
      { color: "#FFFFFF07", lineWidth: 0.3 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL,
      { color: "#ffffff18", lineWidth: 1 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE,
      { color: "#00C8FF", lineWidth: 1.2 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE,
      { color: "#00C8FF", lineWidth: 1.2 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_LIPS,
      { color: "#FF4466", lineWidth: 1.5 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_LEFT_EYEBROW,
      { color: "#ffcc0066", lineWidth: 1 });
    drawingUtils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYEBROW,
      { color: "#ffcc0066", lineWidth: 1 });
  }
  for (const lms of latestHandResult.landmarks) {
    drawingUtils.drawConnectors(lms, HandLandmarker.HAND_CONNECTIONS,
      { color: "#00FF5555", lineWidth: 2 });
    drawingUtils.drawLandmarks(lms, { radius: 3, color: "#00CCFF", fillColor: "#00CCFF33" });
  }

  faceCount.textContent = latestFaceResult.faceLandmarks.length;
  handCount.textContent = latestHandResult.landmarks.length;

  requestAnimationFrame(renderLoop);
}

// ── Buttons ────────────────────────────────────────────────────────────────
micBtn.onclick = () => {
  micMuted = !micMuted;
  micBtn.innerHTML = micMuted ? "&#x1F507;" : "&#x1F399;";
  micBtn.classList.toggle("muted", micMuted);
  if (!isSpeaking) setStatus(micMuted ? "standby" : "listening");
};

spkBtn.onclick = () => {
  spkMuted = !spkMuted;
  spkBtn.innerHTML = spkMuted ? "&#x1F507;" : "&#x1F50A;";
};

startBtn.addEventListener("click", boot);
</script>
</body>
</html>
